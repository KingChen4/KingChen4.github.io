---
title: 程序员的自我修养
date: 2022-10-26 23:36:00
tags: 
  - c++提高
  - 链接、装载与库
categories: c++
top_img: /img/mou.jpeg
cover: false
copyright: true
toc_number: true
---

> **前言**：本文是**《程序员的自我修养》**（俞甲子、石凡、潘爱民）的个人笔记(略去了windows部分)。第一章需要计算机基础知识，也可以略过，不影响阅读后续章节。另原书非常推荐在学习一段时间c/c++之后阅读。

## 温故而知新
1. 计算机三大组成部件： CPU

2. 硬件结构框架， 北桥PCI Bridge， 南桥ISA Bridge
> ![CmpArch](assets/SelfImp/CmpArch.png)

3. 系统软件分为两种：
  一为平台性质的， 比如操作系统，内核，驱动程序，运行库，系统工具等
  二为开发程序所用的,比如编译器，汇编器，链接器等开发工具和开发库
> ![CmpArch2](assets/SelfImp/CmpArch2.png)

4. 内存分段， 利用率太低
> ![mem](assets/SelfImp/mem.png)

5. 内存分页
> ![mem2](assets/SelfImp/mem2.png)

6. MMU 将虚拟地址转换程物理地址,一般集成在cpu 内部了
> ![mem3](assets/SelfImp/mem3.png)

7. 标准线程一般由线程ID, PC,寄存器集和堆栈组成
> ![thread](assets/SelfImp/thread.png)


　　频繁等待的成为IO密集型线程， 少等待的称为CPU密集型， 通常IO 密集型容易获得优先级的提升，线程的优先级改变的三种方式：
* 用户指定
* 根据等待频繁程度修改
* 长时间得不到执行而提升优先级
> ![thread2](assets/SelfImp/thread2.png)

8. Linux 的多线程：
Linux将所有的执行实体(无论是线程还是进程)都称为任务(Task)；
       每一个任务概念上都类似于一个单线程的进程,具有内存空间、执行实体、文件资源等。
       Linux下不同的任务之间可以选择共享内存空间,因而在实际意义上,共享了同一个内存空间的多个任务构成了一个进程,这些任务也就成了这个进程里的线程
| 系统调用 | 作用 |
| ---- | ----|
| fork | 复制当前进程 |
| exec | 使用新的执行映像覆盖当前可执行映像 |
| clone | 创建子进程并从指定位置开始执行 |
> ![proc](assets/SelfImp/proc.png)

9. 线程同步
* 原子操作
* 二元信号量/多元信号量， 信号量初始值为1为二元， 信号量初始值为N 为多元
* 互斥量，与二元信号量相似，互斥量要求由获取者线程释放，信号量整个系统均可获取和释放
* 临界区，与互斥量相似， 但是将本进程创建的锁可见范围控制在本进程内
* 读写锁
| 读写锁状态 | 以共享获取 | 以独占方式获取 |
| ---- | ---- | ---- |
| 自由 | 成功 | 成功 |
| 共享 | 成功 | 等待 |
| 独占 | 等待 | 等待 |
* 条件变量

10. 可重入：一个函数被称为可重入的,表明该函数被重入之后不会产生任何不良后果

11. 过度优化
* 编译器优化
```c++
x = 0;
Thread1 Thread2
lock()  lock()
x++;     x++;
unlock();  unlock();

x最终的值可能为1. 
不同线程使用独立的寄存器。
当某个线程计算完x++后，编译器为了提高速度，并没有将1写回到内存中。
所以另一个线程执行完x++后。最终写回到变量x的值为1
```
* cpu 动态调度换序和编译器优化
```c++
x = y = 0;
Thread1 Thread2
x =1;     y=1;
r1=y;   r2=x;

逻辑上至少一个结果为1，但结果可能是r1=r2=0,执行顺序可能是
x = y = 0;
Thread1 Thread2
r1=y;   y=1;
x =1;   r2=x;
原因在于为了提高效率，编译器或cpu 会将两个不相关的指令换序

volatile 可以
#1.阻止编译器效率将一个变量缓存到寄存器而不写回
#2.阻止编译器调整操作volitile 变量的指令顺序
但无法解决cpu 动态调序
```
* 双检测锁的问题,C11官方推荐的单例实现方式是利用static 变量定义的排他性
```c++
volitile T* pInst = 0;
T* GetInstance(){
    if(pIns == NULL){
        lock();
        if(pInst == NULL) //防止通过第一重判断没有申请到锁的线程
            pInst = new T;
        unlock();                
    }
    return pInst;
}
new 的操作分为申请内存， 构造， 返回地址
构造和返回可以互换， 故程序可能使用到没有构造完成的地址而崩溃

使用cpu 提供的阻止换序方法可以解决
比如barrier（）能阻止该指令之前的命令被换到barrier 之后
```

12. 三种线程模型
* 1对1：用户线程与内核1对1
优：真正的实现并发，线程独立不会互相阻塞
缺：内核线程有限使得用户线程受限
内核线程调度时，上下文切换开销大， 使得用户线程效率低下
* 多对1
> ![Ｍthread](assets/SelfImp/Mthread.png)

　　　优：高效的上下文切换和几乎无限制的用户线程
　　　缺：用户线程阻塞则内核线程阻塞，所有用户进程阻塞
* 多对多
> ![Ｍthread2](assets/SelfImp/Mthread.png)

　　　综合多对1和1对1的优缺






## 编译与链接
### 编译过程（开发视角）
1. 预处理：主要处理源马中的预编译指令
命令：gcc -E hello.c -o hello.i或cpp hello >hello.i
程序：cc1/cc1plus/cc1obj/jc1
后缀:.h,.c->.i , .cpp,.hpp->.ii
过程：
　　处理预编译指令
　　删除注释
　　添加行号和文件标识，方便调试和产生错误警告信息
　　保留#pragma 编译器指令， 因为便编译器需要使用他们
2. 编译：将预处理完的文件进行一系列词法分析，文法分析产生汇编代码
命令：gcc -S hello.i -o hello.s
程序：cc1/cc1plus/cc1obj/jc1
现代编译器通常预处理和编译一起执行，可用命令：
gcc -S hello.c -o hello.s
3. 汇编:将汇编代码专场机器指令
命令：gcc -c hello.s -o hello.o
程序：as
4. 链接：链接库文件得到真正的可执行程序
程序：ld
过程包括地址和空间分配，符号决议和重定位等等
> ![compile](assets/SelfImp/compile.png)
### 编译过程（编译器视角）
* 编译器编译过程（另，书中举了个例子， 可以配合哈工大编译原理公开课的导论来参考原文）
> ![compile2](assets/SelfImp/compile2.png)
* 预处理不归编译器范畴
*  词法分析：将源代码字符序列生成一系列记号，同时做将标识符放入符号表，数字、字符串常量存放到文字表等准备工作，现成工具lex
* 语法分析：根据记号进行上下文无关的语法分析，产生语法树， 同时确定优先级，发现语法错误，现成工具yacc
* 语义分析：由语义分析器进行静态语义分析，通常包括声明和类型的匹配， 类型的转换
* 源码级优化器：对源码级进行优化产生中间代码， 常见的有三址码、P代码， 比如a=2+3 可以直接优化成a=5，由于中间代码的引入，可以使编译器分为前端和后端， 前端与机器无关
* 代码生成器：将中间代码转成目标机器代码
* 目标代码优化器：对目标代码优化，例如使用位移替换乘法运算等

## 目标文件
###目标文件格式
### 目标文件基本内容
## 静态链接
## 可执行文件的装载进程
## 动态链接
## Linux 共享库的组织
## 内存