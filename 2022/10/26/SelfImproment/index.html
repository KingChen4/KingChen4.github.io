<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>程序员的自我修养 | Coder-King</title><meta name="keywords" content="c++提高,链接、装载与库"><meta name="author" content="King Chan"><meta name="copyright" content="King Chan"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="声明：本文是《程序员的自我修养》（俞甲子、石凡、潘爱民）的个人笔记(略去了windows部分)。  1. 温故而知新 计算机三大组成部件： CPU，内存，IO控制芯片  硬件结构框架， 北桥PCI Bridge， 南桥ISA Bridge  系统软件分为两种：  一为平台性质的， 比如操作系统，内核，驱动程序，运行库，系统工具等  二为开发程序所用的,比如编译器，汇编器，链接器等开发工具和开发库">
<meta property="og:type" content="article">
<meta property="og:title" content="程序员的自我修养">
<meta property="og:url" content="http://guangjin.fun/2022/10/26/SelfImproment/index.html">
<meta property="og:site_name" content="Coder-King">
<meta property="og:description" content="声明：本文是《程序员的自我修养》（俞甲子、石凡、潘爱民）的个人笔记(略去了windows部分)。  1. 温故而知新 计算机三大组成部件： CPU，内存，IO控制芯片  硬件结构框架， 北桥PCI Bridge， 南桥ISA Bridge  系统软件分为两种：  一为平台性质的， 比如操作系统，内核，驱动程序，运行库，系统工具等  二为开发程序所用的,比如编译器，汇编器，链接器等开发工具和开发库">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://guangjin.fun/img/dog.jpg">
<meta property="article:published_time" content="2022-10-25T16:00:00.000Z">
<meta property="article:modified_time" content="2024-08-26T15:37:51.235Z">
<meta property="article:author" content="King Chan">
<meta property="article:tag" content="c++提高">
<meta property="article:tag" content="链接、装载与库">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://guangjin.fun/img/dog.jpg"><link rel="shortcut icon" href="/"><link rel="canonical" href="http://guangjin.fun/2022/10/26/SelfImproment/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '程序员的自我修养',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-08-26 23:37:51'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Coder-King" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/dog.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-star"></i><span> 摸鱼</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heartbeat"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/mou.jpeg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Coder-King</a></span><div id="he-plugin-simple"></div><div id="none_space"></div><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-star"></i><span> 摸鱼</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heartbeat"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">程序员的自我修养</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-10-25T16:00:00.000Z" title="发表于 2022-10-26 00:00:00">2022-10-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-08-26T15:37:51.235Z" title="更新于 2024-08-26 23:37:51">2024-08-26</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B/">编程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="程序员的自我修养"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p><strong>声明</strong>：本文是<strong>《程序员的自我修养》</strong>（俞甲子、石凡、潘爱民）的个人笔记(略去了windows部分)。</p>
</blockquote>
<h2 id="1-温故而知新"><a href="#1-温故而知新" class="headerlink" title="1. 温故而知新"></a>1. 温故而知新</h2><ol>
<li><p>计算机三大组成部件： CPU，内存，IO控制芯片</p>
</li>
<li><p>硬件结构框架， 北桥PCI Bridge， 南桥ISA Bridge<br><img src="/assets/SelfImp/CmpArch.png" alt="CmpArch"></p>
</li>
<li><p>系统软件分为两种：<br>  一为平台性质的， 比如操作系统，内核，驱动程序，运行库，系统工具等<br>  二为开发程序所用的,比如编译器，汇编器，链接器等开发工具和开发库<br><img src="/assets/SelfImp/CmpArch2.png" alt="CmpArch2"></p>
</li>
<li><p>内存分段， 利用率太低<br><img src="/assets/SelfImp/mem.png" alt="mem"></p>
</li>
<li><p>内存分页<br><img src="/assets/SelfImp/mem2.png" alt="mem2"></p>
</li>
<li><p>MMU 将虚拟地址转换程物理地址,一般集成在cpu 内部了<br><img src="/assets/SelfImp/mem3.png" alt="mem3"></p>
</li>
<li><p>标准线程一般由线程ID, PC,寄存器集和堆栈组成<br><img src="/assets/SelfImp/thread.png" alt="thread"><br>频繁等待的成为IO密集型线程， 少等待的称为CPU密集型， 通常IO 密集型容易获得优先级的提升，线程的优先级改变的三种方式：</p>
<ul>
<li>用户指定</li>
<li>根据等待频繁程度修改</li>
<li>长时间得不到执行而提升优先级<br><img src="/assets/SelfImp/thread2.png" alt="thread2"></li>
</ul>
</li>
<li><p>Linux 的多线程：<br>Linux将所有的执行实体(无论是线程还是进程)都称为任务(Task)；<br>每一个任务概念上都类似于一个单线程的进程,具有内存空间、执行实体、文件资源等。<br>Linux下不同的任务之间可以选择共享内存空间,因而在实际意义上,共享了同一个内存空间的多个任务构成了一个进程,这些任务也就成了这个进程里的线程</p>
<table>
<thead>
<tr>
<th>系统调用</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>fork</td>
<td>复制当前进程</td>
</tr>
<tr>
<td>exec</td>
<td>使用新的执行映像覆盖当前可执行映像</td>
</tr>
<tr>
<td>clone</td>
<td>创建子进程并从指定位置开始执行</td>
</tr>
</tbody></table>
</li>
</ol>
<p><img src="/assets/SelfImp/proc.png" alt="proc"></p>
<ol start="9">
<li>线程同步</li>
</ol>
<ul>
<li>原子操作</li>
<li>二元信号量&#x2F;多元信号量， 信号量初始值为1为二元， 信号量初始值为N 为多元</li>
<li>互斥量，与二元信号量相似，互斥量要求由获取者线程释放，信号量整个系统均可获取和释放</li>
<li>临界区，与互斥量相似， 但是将本进程创建的锁可见范围控制在本进程内</li>
<li>读写锁<table>
<thead>
<tr>
<th>读写锁状态</th>
<th>以共享获取</th>
<th>以独占方式获取</th>
</tr>
</thead>
<tbody><tr>
<td>自由</td>
<td>成功</td>
<td>成功</td>
</tr>
<tr>
<td>共享</td>
<td>成功</td>
<td>等待</td>
</tr>
<tr>
<td>独占</td>
<td>等待</td>
<td>等待</td>
</tr>
</tbody></table>
</li>
<li>条件变量</li>
</ul>
<ol start="10">
<li><p>可重入：一个函数被称为可重入的,表明该函数被重入之后不会产生任何不良后果</p>
</li>
<li><p>过度优化</p>
</li>
</ol>
<ul>
<li>编译器优化<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">0</span>;</span><br><span class="line"><span class="function">Thread1 Thread2</span></span><br><span class="line"><span class="function"><span class="title">lock</span><span class="params">()</span>  <span class="title">lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">x++</span>;     x++;</span><br><span class="line"><span class="built_in">unlock</span>();  <span class="built_in">unlock</span>();</span><br><span class="line"></span><br><span class="line">x最终的值可能为<span class="number">1.</span> </span><br><span class="line">不同线程使用独立的寄存器。</span><br><span class="line">当某个线程计算完x++后，编译器为了提高速度，并没有将<span class="number">1</span>写回到内存中。</span><br><span class="line">所以另一个线程执行完x++后。最终写回到变量x的值为<span class="number">1</span></span><br></pre></td></tr></table></figure></li>
<li>cpu 动态调度换序和编译器优化<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">x = y = <span class="number">0</span>;</span><br><span class="line">Thread1 Thread2</span><br><span class="line">x =<span class="number">1</span>;     y=<span class="number">1</span>;</span><br><span class="line">r1=y;   r2=x;</span><br><span class="line"></span><br><span class="line">逻辑上至少一个结果为<span class="number">1</span>，但结果可能是r1=r2=<span class="number">0</span>,执行顺序可能是</span><br><span class="line">x = y = <span class="number">0</span>;</span><br><span class="line">Thread1 Thread2</span><br><span class="line">r1=y;   y=<span class="number">1</span>;</span><br><span class="line">x =<span class="number">1</span>;   r2=x;</span><br><span class="line">原因在于为了提高效率，编译器或cpu 会将两个不相关的指令换序</span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> 可以</span><br><span class="line">#<span class="number">1.</span>阻止编译器效率将一个变量缓存到寄存器而不写回</span><br><span class="line">#<span class="number">2.</span>阻止编译器调整操作volitile 变量的指令顺序</span><br><span class="line">但无法解决cpu 动态调序</span><br></pre></td></tr></table></figure></li>
<li>双检测锁的问题,C11官方推荐的单例实现方式是利用static 变量定义的排他性<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">volitile T* pInst = <span class="number">0</span>;</span><br><span class="line"><span class="function">T* <span class="title">GetInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pIns == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span>(pInst == <span class="literal">NULL</span>) <span class="comment">//防止通过第一重判断没有申请到锁的线程</span></span><br><span class="line">            pInst = <span class="keyword">new</span> T;</span><br><span class="line">        <span class="built_in">unlock</span>();                </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pInst;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> 的操作分为申请内存， 构造， 返回地址</span><br><span class="line">构造和返回可以互换， 故程序可能使用到没有构造完成的地址而崩溃</span><br><span class="line"></span><br><span class="line">使用cpu 提供的阻止换序方法可以解决</span><br><span class="line">比如barrier（）能阻止该指令之前的命令被换到barrier 之后</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="12">
<li>三种线程模型</li>
</ol>
<ul>
<li>1对1：用户线程与内核1对1<br>优：真正的实现并发，线程独立不会互相阻塞<br>缺：内核线程有限使得用户线程受限<br>　　内核线程调度时，上下文切换开销大， 使得用户线程效率低下</li>
<li>多对1<br><img src="/assets/SelfImp/Mthread.png" alt="Ｍthread"></li>
</ul>
<p>　　　优：高效的上下文切换和几乎无限制的用户线程<br>　　　缺：用户线程阻塞则内核线程阻塞，所有用户进程阻塞</p>
<ul>
<li>多对多<br><img src="/assets/SelfImp/Mthread.png" alt="Ｍthread2"></li>
</ul>
<p>　　　综合多对1和1对1的优缺</p>
<h2 id="2-编译与链接"><a href="#2-编译与链接" class="headerlink" title="2.编译与链接"></a>2.编译与链接</h2><h3 id="2-1-编译过程（开发视角）"><a href="#2-1-编译过程（开发视角）" class="headerlink" title="2.1 编译过程（开发视角）"></a>2.1 编译过程（开发视角）</h3><ol>
<li>预处理：主要处理源马中的预编译指令<br>命令：gcc -E hello.c -o hello.i或cpp hello &gt;hello.i<br>程序：cc1&#x2F;cc1plus&#x2F;cc1obj&#x2F;jc1<br>后缀:.h,.c-&gt;.i , .cpp,.hpp-&gt;.ii<br>过程：<br>　　处理预编译指令<br>　　删除注释<br>　　添加行号和文件标识，方便调试和产生错误警告信息<br>　　保留#pragma 编译器指令， 因为编译器需要使用他们</li>
<li>编译：将预处理完的文件进行一系列词法分析，文法分析产生汇编代码<br>命令：gcc -S hello.i -o hello.s<br>程序：cc1&#x2F;cc1plus&#x2F;cc1obj&#x2F;jc1<br>现代编译器通常预处理和编译一起执行，可用命令：<br>gcc -S hello.c -o hello.s</li>
<li>汇编:将汇编代码专场机器指令<br>命令：gcc -c hello.s -o hello.o<br>程序：as</li>
<li>链接：链接库文件得到真正的可执行程序<br>程序：ld<br>过程包括地址和空间分配，符号决议和重定位等等<br><img src="/assets/SelfImp/compile.png" alt="compile"></li>
</ol>
<h3 id="2-2-编译过程（编译器视角）"><a href="#2-2-编译过程（编译器视角）" class="headerlink" title="2.2 编译过程（编译器视角）"></a>2.2 编译过程（编译器视角）</h3><ul>
<li><p>编译器编译过程（另，书中举了个例子， 可以配合哈工大编译原理公开课的导论来参考原文）<br><img src="/assets/SelfImp/compile2.png" alt="compile2"></p>
</li>
<li><p>预处理不归编译器范畴</p>
</li>
<li><p>词法分析：将源代码字符序列生成一系列记号，同时做将标识符放入符号表，数字、字符串常量存放到文字表等准备工作，现成工具lex</p>
</li>
<li><p>语法分析：根据记号进行上下文无关的语法分析，产生语法树， 同时确定优先级，发现语法错误，现成工具yacc</p>
</li>
<li><p>语义分析：由语义分析器进行静态语义分析，通常包括声明和类型的匹配， 类型的转换</p>
</li>
<li><p>源码级优化器：对源码级进行优化产生中间代码， 常见的有三址码、P代码， 比如a&#x3D;2+3 可以直接优化成a&#x3D;5，由于中间代码的引入，可以使编译器分为前端和后端， 前端与机器无关</p>
</li>
<li><p>代码生成器：将中间代码转成目标机器代码</p>
</li>
<li><p>目标代码优化器：对目标代码优化，例如使用位移替换乘法运算等</p>
</li>
</ul>
<h2 id="3-目标文件"><a href="#3-目标文件" class="headerlink" title="3.目标文件"></a>3.目标文件</h2><h3 id="3-1-目标文件格式"><a href="#3-1-目标文件格式" class="headerlink" title="3.1 目标文件格式"></a>3.1 目标文件格式</h3><blockquote>
<p>ELF:Excutable Linkable Format</p>
</blockquote>
<p><img src="/assets/SelfImp/ch3_01.png" alt="ch3_01.png"><br><img src="/assets/SelfImp/ch3_02.png" alt="ch3_02.png"><br><img src="/assets/SelfImp/ch3_03.png" alt="ch3_03.png"></p>
<h3 id="3-2-目标文件基本内容"><a href="#3-2-目标文件基本内容" class="headerlink" title="3.2 目标文件基本内容"></a>3.2 目标文件基本内容</h3><p><img src="/assets/SelfImp/ch3_04.png" alt="ch3_04.png"></p>
<ul>
<li>Header:文件属性，包括是否可执行，是静态还是动态及入口地址，目标硬件， 目标操作系统等</li>
<li>.text: 编译后的机器代码</li>
<li>.data: 已初始化的全局变量和静态变量</li>
<li>.bss:未初始化(或等同于未初始化，如static int i&#x3D;0被编译器优化后)的全局变量和静态变量（预留位置，没有内容，在文件中不占据空间</li>
</ul>
<h3 id="3-3-一个有代表的例子"><a href="#3-3-一个有代表的例子" class="headerlink" title="3.3 一个有代表的例子"></a>3.3 一个有代表的例子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gcc -c SimpleSection.c</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="type">int</span> global_init_val = <span class="number">84</span>;</span><br><span class="line"><span class="type">int</span> global_uninit_val;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"> <span class="type">static</span> <span class="type">int</span> static_var = <span class="number">85</span>;</span><br><span class="line"> <span class="type">static</span> <span class="type">int</span> static_var2;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> b ;</span><br><span class="line">  <span class="built_in">func1</span>(static_var + static_var2 + a+b);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/assets/SelfImp/ch3_05.png" alt="ch3_05.png"></p>
<blockquote>
<p>*CONTENTS 代表该段在文件中存在， ALLOC表示不存在，ox0000450即文件大小， 书中正是1104，注意.bss 的File off </p>
</blockquote>
<p><img src="/assets/SelfImp/ch3_06.png" alt="ch3_06.png"><br><img src="/assets/SelfImp/ch3_07.png" alt="ch3_07.png"><br><img src="/assets/SelfImp/ch3_08.png" alt="ch3_08.png"></p>
<p>分析：</p>
<ul>
<li>.text 反汇编结果大小0x5b</li>
<li>.data 大小为8字节，对应代码的static_var和global_init_varabal</li>
<li>.rodata大小为4字节，对应常量：“%d\n”</li>
<li>.bss 大小为4字节，对应static_var2, 因为有些编译器只会对全局未初始化的变量记录一个未定义的全局变量符号</li>
</ul>
<h3 id="3-4-其他常见的段"><a href="#3-4-其他常见的段" class="headerlink" title="3.4 其他常见的段"></a>3.4 其他常见的段</h3><p><img src="/assets/SelfImp/ch3_09.png" alt="ch3_09.png"></p>
<p>gcc指定自定义段：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((<span class="built_in">section</span>(<span class="string">&quot;FOO&quot;</span>))) <span class="type">int</span> global = <span class="number">42</span>;</span><br><span class="line">__attribute__((<span class="built_in">section</span>(<span class="string">&quot;BAR&quot;</span>))) <span class="type">void</span> foo&#123;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意不要以”.”开头，容易冲突</p>
</blockquote>
<h3 id="3-5-ELF-文件结构描述"><a href="#3-5-ELF-文件结构描述" class="headerlink" title="3.5 ELF 文件结构描述"></a>3.5 ELF 文件结构描述</h3><p><img src="/assets/SelfImp/ch3_10.png" alt="ch3_10.png"></p>
<h4 id="3-5-1-ELF文件头"><a href="#3-5-1-ELF文件头" class="headerlink" title="3.5.1 ELF文件头"></a>3.5.1 ELF文件头</h4><p><img src="/assets/SelfImp/ch3_11.png" alt="ch3_11.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /usr/include/elf.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> e_ident[<span class="number">16</span>]; <span class="comment">// 输出图中version以上的内容</span></span><br><span class="line">  Elf32_Half e_type;    <span class="comment">//ELF文件类型</span></span><br><span class="line">  Elf32_Half e_machine; <span class="comment">//ELF文件的CPU平台属性</span></span><br><span class="line">  Elf32_Word e_version; <span class="comment">//ELF版本号</span></span><br><span class="line">  Elf32_Addr e_entry;   <span class="comment">//ELF文件的入口虚拟地址。重定向文件入口地址为0</span></span><br><span class="line">  Elf32_Off  e_phoff;        <span class="comment">//暂时不关心，链接和执行视图介绍</span></span><br><span class="line">  Elf32_Off  e_shoff;   <span class="comment">//段表在文件中的偏移</span></span><br><span class="line">  Elf32_Word e_flags;   <span class="comment">//文件头标志位</span></span><br><span class="line">  Elf32_Half e_ehsize;  <span class="comment">//文件头本身的大小 sizeof(ELF32_Ehdr)</span></span><br><span class="line">  Elf32_Half e_phentsize;     <span class="comment">//暂时不关心，链接和执行视图介绍</span></span><br><span class="line">  Elf32_Half e_phnum;         <span class="comment">//暂时不关心，链接和执行视图介绍</span></span><br><span class="line">  Elf32_Half e_shentisize; <span class="comment">//段表描述符大小 sizeof(ELF32_Shdr)</span></span><br><span class="line">  Elf32_Half e_shnum;      <span class="comment">//段表描述符数量</span></span><br><span class="line">  Elf32_Half e_shstrndx;   <span class="comment">//段表字符串表所在的段在段表中的下标</span></span><br><span class="line">&#125; Elf32_Ehdr;</span><br></pre></td></tr></table></figure>

<blockquote>
<p> OS加载可执行文件时会检查魔数，其构成为：0x7f,‘E’,‘L’,‘F’,文件字长类型，字节序类型，主版本号，其余9字节未定义，一般为0，有些平台会用做扩展标志</p>
</blockquote>
<h4 id="3-5-2-段表"><a href="#3-5-2-段表" class="headerlink" title="3.5.2 段表"></a>3.5.2 段表</h4><p><img src="/assets/SelfImp/ch3_12.png" alt="ch3_12.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ‘/usr/include/elf.h’ struct Elf32_Shdr</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">  Elf32_Word  sh_name;  <span class="comment">//段名在字符串表 &quot;.shstrtab&quot;的偏移量</span></span><br><span class="line">  Elf32_Word  sh_type;  <span class="comment">//段的类型</span></span><br><span class="line">  Elf32_Word  sh_flags; <span class="comment">//段的标志位</span></span><br><span class="line">  Elf32_Addr  sh_addr;  <span class="comment">//段虚拟地址:如果可以被加载，则为加载后的虚拟地址。否则为0</span></span><br><span class="line">  Elf32_Off   sh_offset;<span class="comment">//段在文件中的偏移</span></span><br><span class="line">  Elf32_Word  sh_size;  <span class="comment">//段的大小</span></span><br><span class="line">  Elf32_Word  sh_link;  <span class="comment">//段链接信息</span></span><br><span class="line">  Elf32_Word  sh_info;  <span class="comment">//段链接信息</span></span><br><span class="line">  Elf32_Word  sh_addralign; <span class="comment">//段地址对齐</span></span><br><span class="line">  Elf32_Word  sh_entsize;   <span class="comment">//项的长度</span></span><br><span class="line">&#125; Elf32_Shdr;</span><br></pre></td></tr></table></figure>
<p><img src="/assets/SelfImp/ch3_13.png" alt="ch3_13.png"></p>
<ul>
<li>中间不连续相差几个字节是因为内存对齐，段表长&#x3D;11个段*sizeof(Elf32_Shdr)</li>
<li>rel.text 为重定位表，sh_type&#x3D;SH_REL, sh_link&#x3D;符号表的下标， sh_info&#x3D;作用段的下标</li>
<li>字符串表（.shstrtab,.strtab等）保存ELF 中的字符串，下标选择</li>
</ul>
<h3 id="3-6-符号表-stmtab"><a href="#3-6-符号表-stmtab" class="headerlink" title="3.6 符号表(.stmtab)"></a>3.6 符号表(.stmtab)</h3><p>链接的接口，可以用nm 直接查看</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//符号表时Elf32_Sym 的数组</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">  Elf32_Word    st_name; <span class="comment">//符号名，包含了符号名在字符串表中的下标</span></span><br><span class="line">  Elf32_Addr    st_value; <span class="comment">//符号相对应的值。</span></span><br><span class="line">  Elf32_Word    st_size; <span class="comment">//符号大小</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> st_info; <span class="comment">//符号类型（低4位）和绑定信息（高28位）</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> st_other;<span class="comment">//目前为0，暂时没用</span></span><br><span class="line">  Elf32_Half    st_shndx;<span class="comment">//符号所在的段</span></span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure>
<p><img src="/assets/SelfImp/ch3_14.png" alt="ch3_14.png"></p>
<ul>
<li>num&#x3D;2 是一个段，Ndx&#x3D;1&#x3D;&gt;段表中的下标为2的段 ， 即.text</li>
<li>func1和main位于xxx.c中， 位于.text段,ndx&#x3D;1 （objdump -x&#x2F;readelf -a可以验证）</li>
<li>printf 是引用变量， ndx&#x3D;SHN_UNDEF</li>
<li>statuc_var.1533 是静态变量,仅编译单元内可见，bind&#x3D;LOCAL位于.data</li>
<li>global_init_var位于.data,ndx&#x3D;3(书中写成了.bss是错的)</li>
<li>statuc_var2 位于.bss, ndx&#x3D;4, global_uninit_var 位于COMMON，ndx&#x3D;COM（呼应第一节）<br> 特殊符号 ：连接器产生可执行文件时，由链接器产生，可以直接使用，后续章节再详细介绍<br>如：__excutable_start 程序起始地址,__etext 代码段结束地址等</li>
</ul>
<h3 id="3-7-符号修饰与函数签名"><a href="#3-7-符号修饰与函数签名" class="headerlink" title="3.7 符号修饰与函数签名"></a>3.7 符号修饰与函数签名</h3><p>gcc的c++为例，可以通过c++file _Z4funci 解析被修饰过的名称<br><img src="/assets/SelfImp/ch3_15.png" alt="ch3_15.png"><br>_Z开头， N开始域名，4结束域名，E结束函数体， E后加参数类型 详略</p>
<h3 id="3-8-强弱符号"><a href="#3-8-强弱符号" class="headerlink" title="3.8 强弱符号"></a>3.8 强弱符号</h3><p>多个目标文件有相同的全局符号 链接时会出现重复定义的错误，则称为强符号<br>强符号：编译器默认函数和初始化了的全局变量<br>弱符号：未初始化的全局变量<br>可以通过__attribute__((weak)) 来定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> ext; <span class="comment">//外部引用，非强非弱</span></span><br><span class="line"><span class="type">int</span> weak;<span class="comment">//弱</span></span><br><span class="line"><span class="type">int</span> strong = <span class="number">1</span>;<span class="comment">// 强</span></span><br><span class="line">__attribute__((weak)) weak2=<span class="number">2</span>;<span class="comment">//弱</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;<span class="comment">//强</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>链接器处理规则：</p>
<ul>
<li>不允许强符号多次定义， 否则报重定义错</li>
<li>多个目标文件，一强多弱，选用强符号</li>
<li>全为弱符号则选取占用空间最大的一个</li>
</ul>
<h3 id="3-9-强弱引用"><a href="#3-9-强弱引用" class="headerlink" title="3.9 强弱引用"></a>3.9 强弱引用</h3><p> 必须在外部找到符号的定义，否则报未定义错误，称为强引用，后续详述<br>可以通过__attribute__((weakref))指定弱符号</p>
<ul>
<li><p>这种弱符号和弱引用对于库来说十分有用：<br>程序可以对某些扩展功能模块的引用定义为弱引用，当我们将扩展模块与程序链接在一起时,功能模块就可以正常使用如果我们去掉了某些功能模块,那么程序也可以正常链接,只是缺少了相应的功能,这使得程序的功能更加容易裁剪和组合。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((weakref)) <span class="function"><span class="type">void</span> <span class="title">foo</span> <span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(foo) <span class="comment">//弱引用默认编译器设为0</span></span><br><span class="line">          <span class="built_in">foo</span>();</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//未找到定义时，可以编译运行</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>库中定义的弱符号可以被用户定义的强符号所覆盖,从而使得程序可以使用自定义版本的库函数</p>
</li>
</ul>
<h2 id="4-静态链接"><a href="#4-静态链接" class="headerlink" title="4. 静态链接"></a>4. 静态链接</h2><h3 id="4-1-合并-o文件"><a href="#4-1-合并-o文件" class="headerlink" title="4.1 合并.o文件"></a>4.1 合并.o文件</h3><p><img src="/assets/SelfImp/ch4_01.png" alt="ch4_01.png"></p>
<p>两步链接：</p>
<ul>
<li>空间与地址分配<ul>
<li>扫描所有的输入目标文件,并且获得它们的各个段的长度属性和位置</li>
<li>将输入目标文件中的符号表中所有的符号定义和符号引用收集起来,统放到一个全局符号表</li>
<li>通过上面的过程, 链接器将能够获得所有输入目标文件的段长度,并且将它们合并,计算出输出文件中各个段合并后的长度与位置,并建立映射关系</li>
</ul>
</li>
<li>符号解析与重定位<ul>
<li>用上面第一步中收集到的所有信息,读取输入文件中段的数据、重定位信息,并且进行符号解析与重定位、调整代码中的地址等</li>
</ul>
</li>
</ul>
<h3 id="4-2-简单的例子"><a href="#4-2-简单的例子" class="headerlink" title="4.2 简单的例子"></a>4.2 简单的例子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* a.c */</span>                        </span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> shared;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">  <span class="built_in">swap</span>(&amp;a, &amp;shared);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* b.c */</span></span><br><span class="line"><span class="type">int</span> shared = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span> </span>&#123;</span><br><span class="line">   *a ^= *b ^= *a ^= *b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/****</span></span><br><span class="line"><span class="comment">$ gcc -c a.c b.c</span></span><br><span class="line"><span class="comment">$ ld a.o b.o -e main -o ab</span></span><br><span class="line"><span class="comment">-e main 表示将main函数作为程序的入口。ld默认的程序入口为_start。</span></span><br><span class="line"><span class="comment">-o ab   表示链接输出文件名为ab, 默认为a.out。</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>
<p><img src="/assets/SelfImp/ch4_02.png" alt="ch4_02.png"></p>
<blockquote>
<p>VMA (VIrtual Memery Address)， LMA（Load Memory Address），有些嵌入式中会不一样， ld 之后ab 的VMA 变为0x8048094,Linux 中的ELF默认从 0x8048000 开始， 后续介绍</p>
</blockquote>
<p><strong>空间与地址分配</strong><br><img src="/assets/SelfImp/ch4_03.png" alt="ch4_03.png"></p>
<p>符号地址的确定：链接第一步时已经计算好了.text&#x3D;0x08048094,.data &#x3D; 0x08049108的起始位置，基于此以及合并前的偏移量计算各符号的虚拟地址，如：<br>main &#x3D; 0x08048094[.text]+0x00<br>swap &#x3D; 0x08048094[.text]+0x34<br>shared&#x3D; 0x08049108[.data]+0x00</p>
<p><strong>符号解析与重定位</strong><br><img src="/assets/SelfImp/ch4_04.png" alt="ch4_04.png"></p>
<ol>
<li><p>编译器不确定shared 和swap 的地址， 所以给了捏造的0x0000和0xfffffc<br><img src="/assets/SelfImp/ch4_05.png" alt="ch4_05.png"></p>
</li>
<li><p>由.rel.data 段（表）确定有哪些需要重定位的数据， .rel.text 段（表）确定有哪些需要重定位的代码<br><img src="/assets/SelfImp/ch4_06.png" alt="ch4_06.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">   Elf32_Addr r_offset; <span class="comment">//重定位入口在对应段中的偏移</span></span><br><span class="line">   Elf32_Word r_info;   <span class="comment">//重定位入口的类型和符号</span></span><br><span class="line">&#125; Elf32_Rel;</span><br></pre></td></tr></table></figure>
<p><img src="/assets/SelfImp/ch4_07.png" alt="ch4_07.png"></p>
</li>
<li><p>符号解析在重定位时查找全局符号表（每一个UND均已经被消灭合并）<br><img src="/assets/SelfImp/ch4_08.png" alt="ch4_08.png"></p>
</li>
<li><p>指令修正：<br>R_386_32 方式&#x3D; S+A<br>R_386_PC32方式 &#x3D; S+A -P<br>A &#x3D; 保存在被修正位置的值<br>S &#x3D; 符号实际地址， 即r_info 高24位<br>P &#x3D; 被修正的位置， 可通过r_offset 计算得到</p>
</li>
<li><p>COMMON 块， 例如前面提到到的未初始化的全局变量 这种弱符号在链接时通过全局符号表才能确定最终大小并将其输出到.bss 段<br>int global <strong>attribute</strong>((nocommon)) &#x2F;&#x2F;声明不将之放在common 块中， 此时global 为强符号，也可以通过gcc -fnocommon进行设置</p>
</li>
</ol>
<h3 id="4-3-C-相关问题"><a href="#4-3-C-相关问题" class="headerlink" title="4.3 C++ 相关问题"></a>4.3 C++ 相关问题</h3><ul>
<li>重复代码消除<ul>
<li>例如模板， 多个编译单元互相不知道对方生成了那些模板实例<br>  一个通用 的做法是将实例代码放到单独的段中，以此，a生成的.temp.add<int>和b 生成的.temp.add<float>能被正确的区分、合并<br>  gcc 中命名为.gnu.linkonce.name,name 表示函数模板修饰后的名称<br>虚函数，内联，构造，拷贝构造， 赋值类似。<br>这样做的一个问题， 如果多目标使用不同编译器版本或选项，则相同的段内容不同，只能随机选择一个并发出一个warning</li>
<li>函数级别链接可以让编译器把所有的函数输出到独立的段中，链接器使用时可以过滤没有用到的函数，以此减少了文件长度， 但会减慢链接过程， 因为链接器需要极端函数间的关系以及复杂的重定位关系</li>
</ul>
</li>
<li>全局构造和析构<ul>
<li>.init 保存进程初始化代码， 全局初始化代码放在这里， main 执行之前执行</li>
<li>.fini 保存进程结束代码， 全局析构代码放在这里， main 执行结束时执行</li>
</ul>
</li>
<li>目前c++ ABI 标准混乱</li>
</ul>
<h3 id="4-4-静态库链接"><a href="#4-4-静态库链接" class="headerlink" title="4.4 静态库链接"></a>4.4 静态库链接</h3><ul>
<li>静态库可以看成是一组目标文件的压缩集合， ar -t {file} 可以看到里面包含的.o</li>
<li>查找目标函数是否在该静态文件中可以<br><img src="/assets/SelfImp/ch4_09.png" alt="ch4_09.png"></li>
<li>链接自动关联相关的.o<br><img src="/assets/SelfImp/ch4_10.png" alt="ch4_10.png"></li>
</ul>
<h3 id="4-5-链接过程控制"><a href="#4-5-链接过程控制" class="headerlink" title="4.5 链接过程控制"></a>4.5 链接过程控制</h3><p>一般情况下不需要特别关注， 但有时有特殊要求时需要处理， 比如OS 内核， BIOS,一些没有os 的情况下运行的程序<br>方式：</p>
<ul>
<li>使用命令行指定参数，例如ld 的-o,-e等</li>
<li>将链接指令放在目标文件里，比如PE 编译器中的.drectve用来传递参数</li>
<li>使用链接脚本，最灵活强大的方法<ul>
<li>ld -verbose 查看脚本， 默认的脚本位于&#x2F;usrl&#x2F;lib&#x2F;ldscript 下</li>
<li>ld -T 指定脚本</li>
<li>示例及脚本解析略</li>
</ul>
</li>
</ul>
<h3 id="4-6-BFD库"><a href="#4-6-BFD库" class="headerlink" title="4.6 BFD库"></a>4.6 BFD库</h3><ul>
<li>这个库目的在于希望通过统一的接口来处理不同的文件格式，以此隔离编译器，链接器和具体的目标文件</li>
<li>现在的gcc ， 链接器，调试器均使用BSD来处理目标文件，而不是直接操作</li>
</ul>
<h2 id="6-可执行文件的装载进程"><a href="#6-可执行文件的装载进程" class="headerlink" title="6. 可执行文件的装载进程"></a>6. 可执行文件的装载进程</h2><h3 id="6-1-进程的创建"><a href="#6-1-进程的创建" class="headerlink" title="6.1 进程的创建"></a>6.1 进程的创建</h3><ol>
<li><p>创建一个独立的虚拟空间</p>
<ul>
<li>linux 内核只分配一个页目录（Page Directory），等后面程序发生页错误时再设置</li>
</ul>
</li>
<li><p>读取可执行文件头， 建立虚拟空间与可执行文件的映射关系</p>
<ul>
<li>例如ELF 只有一个.text, 虚拟地址为0x08048000， 大小为0x000e1, 对齐为0x1000(4kb),则映射如图：</li>
<li>这种映射关系保存在OS 内部的一个数据结构中， linux 中称为VMA<br><img src="/assets/SelfImp/ch6_01.png" alt="ch6_01.png"></li>
</ul>
</li>
<li><p>将cpu 的指令寄存器设置成可执行文件的入口地址，启动运行</p>
</li>
<li><p>程序运行时，发现物理页为空，则OS 页错误处理例程通过VMA 找到页面对应于可执行文件的偏移，将其载入物理页<br>*想到一个问题，程序运行时， 删除文件并不会造成程序崩溃是为什么呢？<br>因为linux  在删除磁盘文件， 必须等所有使用该文件的进程都关闭才会真正删除</p>
</li>
</ol>
<h3 id="6-2-进程寻存空间的分布"><a href="#6-2-进程寻存空间的分布" class="headerlink" title="6.2 进程寻存空间的分布"></a>6.2 进程寻存空间的分布</h3><ul>
<li><p>操作系统并不关心ELF各段的内容，只关注装载相关的问题， 最主要的就是权限，权限组合基本上是三种：</p>
<ul>
<li>以代码段为代表的权限为可读可执行的段</li>
<li>以数据段和BSS段为代表的权限为可读可写的段</li>
<li>以只读数据段为代表的权限为只读的段<br>是故，可以合并相同权限的段(sections)，把它当成一个段(Segments)进行映射以节省空间<br><img src="/assets/SelfImp/ch6_02.png" alt="ch6_02.png"></li>
</ul>
</li>
<li><p>一个例子</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">       <span class="built_in">sleep</span>(<span class="number">1000</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$gcc -<span class="type">static</span> SectionMapping.c -o SectionMapping.elf</span><br></pre></td></tr></table></figure>
<p><img src="/assets/SelfImp/ch6_03.png" alt="ch6_03.png"><br><img src="/assets/SelfImp/ch6_04.png" alt="ch6_04.png"><br><img src="/assets/SelfImp/ch6_05.png" alt="ch6_05.png"></p>
</li>
<li><p>程序头表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">  Elf32_Word    p_type;                 <span class="comment">/* Segment type */</span></span><br><span class="line">  Elf32_Off     p_offset;               <span class="comment">/* Segment file offset */</span></span><br><span class="line">  Elf32_Addr    p_vaddr;                <span class="comment">/* Segment virtual address */</span></span><br><span class="line">  Elf32_Addr    p_paddr;                <span class="comment">/* Segment physical address */</span></span><br><span class="line">  Elf32_Word    p_filesz;               <span class="comment">/* Segment size in file */</span></span><br><span class="line">  Elf32_Word    p_memsz;                <span class="comment">/* Segment size in memory */</span></span><br><span class="line">  Elf32_Word    p_flags;                <span class="comment">/* Segment 权限属性 */</span></span><br><span class="line">  Elf32_Word    p_align;                <span class="comment">/* Segment alignment */</span></span><br><span class="line">&#125; Elf32_Phdr;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-3-堆栈"><a href="#6-3-堆栈" class="headerlink" title="6.3 堆栈"></a>6.3 堆栈</h3><p><img src="/assets/SelfImp/ch6_06.png" alt="ch6_06.png"></p>
<ul>
<li>col1:VMA 的范围</li>
<li>col2:VMA 权限，rwx可读可写可执行，p 表示私有（COW）, s表示共享</li>
<li>col3:VMA对应的Segment 在文件中的偏移</li>
<li>col5:映射文件节点号</li>
<li>vdso:内核相关</li>
</ul>
<p>一个进程基本上可以分为如下几种ⅤMA区域<br>　　a. 代码VMA,权限只读、可执行;；有映像文件。<br>　　b. 数据VMA,权限可读写、可执行；有映像文件。<br>　　c. 堆VMA,权限可读写、可执行；无映像文件,匿名,可向上扩展。<br>　　d. 栈VMA,权限可读写、不可执行；无映像文件,匿名,可向下扩展<br><img src="/assets/SelfImp/ch6_06.png" alt="ch6_06.png"></p>
<h3 id="6-4-Linux-内核装载ELF-过程简介"><a href="#6-4-Linux-内核装载ELF-过程简介" class="headerlink" title="6.4 Linux 内核装载ELF 过程简介"></a>6.4 Linux 内核装载ELF 过程简介</h3><ul>
<li>bash 进程fork 一个进程</li>
<li>新进程调用execve族进程<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//minibash</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;minibash$&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,buf);</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">execlp</span>(buf,<span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;exec error\n&quot;</span>);                        </span><br><span class="line">        &#125;<span class="keyword">else</span> (pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> status;</span><br><span class="line">            <span class="built_in">waitpid</span>(pid, &amp;status, <span class="number">0</span>);                                                </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;fork error!\n&quot;</span>);        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>进入对应的系统调用入口， sys_exceve(), 检查及复制参数</li>
<li>调用do_exceve(),查找被执行文件，并读取128字节</li>
<li>调用serch_binary_handle(),根据读入的128字节判断文件格式，并调用对应的处理过程<ul>
<li>如‘elf’,’cafe’(java 使用)，‘#!&#x2F;bin&#x2F;bash’等</li>
</ul>
</li>
<li>调用load_elf_binary()<ul>
<li>检查ELF 格式的有效性， 如魔数， 程序头表中Segment的数量</li>
<li>寻找动态链接的.interp 段，设置动态链接器路径</li>
<li>根据可执行文件程序头的描述，对ELF 进行映射</li>
<li>初始化ELF 进程环境</li>
<li>将系统调用返回地址设为ELF 可执行文件的入口， 静态链接的ELF可执行文件为e_entry所指的地址， 动态链接的ELF可执行文件为动态链接器</li>
<li>返回系统调用sys_execve,进入用户态时，EIP 寄存器直接跳转到ELF程序入口地址， 开始新程序执行</li>
</ul>
</li>
</ul>
<h2 id="7-动态链接"><a href="#7-动态链接" class="headerlink" title="7. 动态链接"></a>7. 动态链接</h2><h3 id="7-1-一个简单的例子"><a href="#7-1-一个简单的例子" class="headerlink" title="7.1 一个简单的例子"></a>7.1 一个简单的例子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Program1.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Lib.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">foobar</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*Program2.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Lib.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">foobar</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*Lib.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foobar</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Printing from Lib.so %d&quot;</span>,i);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*Lib.h*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> LIB_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LIB_H</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foobar</span><span class="params">(<span class="type">int</span> i)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">gcc -fPIC -shared -o Lib.so Lib.c</span><br><span class="line">gcc -o Program1 Program1.c Lib.so</span><br><span class="line">gcc -o Program1 Program2.c Lib.so</span><br></pre></td></tr></table></figure>
<p><img src="/assets/SelfImp/ch7_01.png" alt="ch7_01.png"></p>
<ul>
<li>foobar是一个定义在某个动态共享对象中的函数,链接器会将这个符号的引用标记为一个动态链接的符号,不对它进行地址重定位,把这个过程留到装载时再进行</li>
<li>Lib.so中保存了完整的符号信息(运行时进行动态链接还须使用符号信息),把Lib.so也作为链接的输入文件之一,链接器在解析符号时就可以知道:foobar是一个定义在Lib.so的动态符号。这样链接器就可以对 foobar的引用做特殊的处理,使它成为一个对动态符号的引用</li>
<li>动态链接程序运行时地址空间分布<br><img src="/assets/SelfImp/ch7_02.png" alt="ch7_02.png"><br><img src="/assets/SelfImp/ch7_03.png" alt="ch7_03.png"><br>地址空间说明：<ul>
<li>.&#x2F;Lib.so同样被映射到了VMA </li>
<li>ld-2.6.1.so linux 下的动态链接库,系统开始program 之前把控制权交给动态链接器， 完成动态链接之后再把控制权交给program1</li>
<li>libc-2.6.1.so 动态链接形式的c 语言运行库</li>
<li>除了elf 文件类型的区别之外，动态链接模块的装载地址时从0x00开始的，但是映射文件可以看出实际地址是0xb7efc000, 由此推断， 共享对象的最终装载地址在编译时是不确定的</li>
</ul>
</li>
</ul>
<h3 id="7-2-地址无关代码"><a href="#7-2-地址无关代码" class="headerlink" title="7.2 地址无关代码"></a>7.2 地址无关代码</h3><ul>
<li>share 装载时重定位，对于so来说，如果数据段中有绝对地址引用则编译器和链接器生成一个重定位表，动态链接据此进行重定位,数据部分各进程有一份副本没有问题， 但指令部分修改后无法再多个进程中共享，如此失去其节省内存的优势</li>
<li>fPIC 地址无关代码，通过将指令中需要修改的部分分离出来跟数据部分放在一起实现<br><img src="/assets/SelfImp/ch7_04.png" alt="ch7_04.png"><ol>
<li>模块内部调用或跳转<ul>
<li>相对跳转和调用，存在全局符号介入问题，后续介绍</li>
</ul>
</li>
<li>模块内部数据访问<ul>
<li>相对地址访问</li>
</ul>
</li>
<li>模块间数据访问<ul>
<li>间接访问GOT<br><img src="/assets/SelfImp/ch7_05.png" alt="ch7_05.png"><br><img src="/assets/SelfImp/ch7_06.png" alt="ch7_06.png"><br><img src="/assets/SelfImp/ch7_07.png" alt="ch7_07.png"></li>
</ul>
</li>
<li>模块间的调用跳转<ul>
<li>间接跳转和调用GOT（GOT 位于数据段）,存在性能问题， elf 有更好的处理， 后续介绍<br><img src="/assets/SelfImp/ch7_08.png" alt="ch7_08.png"><br><img src="/assets/SelfImp/ch7_08.png" alt="ch7_09.png"><br><img src="/assets/SelfImp/ch7_08.png" alt="ch7_10.png"></li>
</ul>
</li>
<li>模块间的调用跳转</li>
</ol>
<ul>
<li>间接跳转和调用GOT（GOT 位于数据段）,存在性能问题， elf 有更好的处理， 后续介绍<br><img src="/assets/SelfImp/ch7_11.png" alt="ch7_11.png"><ol start="6">
<li>模块内全局变量<ul>
<li>如果lib.so 定义了一个全局变量G,而进程A，B 都使用了lib.so, AB 修改G 时互不影响，因为G 已经变成了副本</li>
<li>如果将上述情况改为线程AB， 则G 的修改对AB 相互可见</li>
<li>有种需求希望情况1 相互可见实现进程间通讯， 情况2 不可见防止线程间干扰， 后续介绍解决方案 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">		//一个共享对象定义了global</span><br><span class="line">//module.c</span><br><span class="line">extern int global;</span><br><span class="line">int foo()&#123;</span><br><span class="line">    global = 1;</span><br><span class="line">&#125;</span><br><span class="line">//此时无法判断global是定义在其他目标文件还是另一个共享对象中</span><br><span class="line">//ELF编译时将模块内的全局变量当初定义在其他模块的变量处理， 即情况4</span><br><span class="line">//共享模块被加载时，如果可执行文件中有副本， 则动态链接器将GOT指向</span><br><span class="line">//正确的地址，反之则指向模块内部的该变量副本</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>-fpic和-fPIC的区别在于前者有平台限制， 故通常使用后者</li>
<li>使用readelf -d foo.so |grep TEXTREL 有输出则表示该DSO 是PIC 的，TEXTREL表示代码段重定位地址</li>
<li>对于可执行文件来说， 如果可执行文件时动态链接的，那么gcc 会使用PIC的方法来产生可执行文件的代码段</li>
</ul>
</blockquote>
<h3 id="7-3-延迟绑定PLT"><a href="#7-3-延迟绑定PLT" class="headerlink" title="7.3 延迟绑定PLT"></a>7.3 延迟绑定PLT</h3><ul>
<li>由动态链接器完成， 函数第一次使用时才被加载Glibc由 _dl_runtime_resolve（）进行函数的绑定工作<ul>
<li>.got 保存全局变量的引用</li>
<li>.got.plt 保存函数引用的地址，即外部函数的引用全部被分离至此<ul>
<li>第一项保存”.dynamic“的段地址</li>
<li>第二项保存本模块的ID</li>
<li>第三项保存_dl_runtime_resolve 函数地址<ul>
<li>第二三项由动态链接器在装载共享模块时负责初始化</li>
</ul>
</li>
<li>其余项为外部函数引用<br><img src="/assets/SelfImp/ch7_12.png" alt="ch7_12.png"></li>
</ul>
</li>
<li>.plt 存放plt 代码， 地址无关故与代码段合成一个Segment装入内存</li>
</ul>
</li>
</ul>
<h3 id="7-4-动态链接的相关结构"><a href="#7-4-动态链接的相关结构" class="headerlink" title="7.4 动态链接的相关结构"></a>7.4 动态链接的相关结构</h3><ul>
<li>”.interp”(interpreter 的缩写)段：ELF映射到VMA后，OS先启动一个动态链接器完成动态链接器工作， 该段负责指名动态链接器的位置<br><img src="/assets/SelfImp/ch7_13.png" alt="ch7_13.png"></li>
<li>“.dynamic”段：该段保存了动态链接器的基本信息<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//elf.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    Elf32_Sword d_tag;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        Elf32_Word d_val;</span><br><span class="line">        Elf32_Addr d_ptr;            </span><br><span class="line">    &#125;d_un;</span><br><span class="line">&#125;Elf32_Dyn;</span><br></pre></td></tr></table></figure>
<img src="/assets/SelfImp/ch7_14.png" alt="ch7_14.png"><br><img src="/assets/SelfImp/ch7_15.png" alt="ch7_15.png"></li>
<li>“.dynsym”:动态符号表， 只保存了与动态链接相关的符号（.symtab 包含所有符号，包括.dynsym 中的）；“.dynstr”动态符号字符串表；“.hash”:加快符号的查找过程<br><img src="/assets/SelfImp/ch7_16.png" alt="ch7_16.png"></li>
<li>“.rel.dyn”,”.rel.plt”类似于”.rel.text”,”.rel.data”, 是专门用于动态链接重定位的段， 前者对 数据引用进行修正， 修正位置为.got 和数据段， 后者对函数引用进行修正， 作用位置于.got.plt<br><img src="/assets/SelfImp/ch7_17.png" alt="ch7_17.png"><br><img src="/assets/SelfImp/ch7_18.png" alt="ch7_18.png"></li>
</ul>
<h3 id="7-5-动态链接的步骤和实现"><a href="#7-5-动态链接的步骤和实现" class="headerlink" title="7.5 动态链接的步骤和实现"></a>7.5 动态链接的步骤和实现</h3><ul>
<li>动态链接器自举：动态链接器本身是一个共享对象，其入口地址即使自举代码入口，操作系统将进程控制权交给它时开始执行自举<ul>
<li>首先找到自己的GOT, 找到链接器本身的.daynamic</li>
<li>通过.daynamic 找到链接器自身的重定位表和符号表，重定位它们</li>
<li>动态链接器开始使用自己的全局变量和静态变量</li>
</ul>
</li>
<li>装载共享对象<ul>
<li>完成自举后，动态链接器将可执行文件和链接器本身的符号表合成全局符号表</li>
<li>根据.dynamic 查找需要的共享文件名字， 并将它们放入装载集合中</li>
<li>找到文件后读取ELF 和.dynamic 将之对应的数据段代码段映射到内存空间中</li>
<li>如果该文件还依赖于其他共享文件，则将所以依赖的共享对象名字放入装载集合，循环直至所有的共享对象被装载进来</li>
<li>当一个共享对象被装载时，符号表会被合并入全局符号表中<ul>
<li>为避免全局符号接入，linux 采用如果存在相同的符号名则后加入的符号被忽略的策略<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a1.c</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a1.c\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//a2.c</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a2.c\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//b1.c</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">a</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">b1</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="built_in">a</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//b2.c</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">a</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">b2</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="built_in">a</span>();</span><br><span class="line">&#125;</span><br><span class="line">gcc -fPIC -shared a1.c -o a1.so</span><br><span class="line">gcc -fPIC -shared a2.c -o a2.so</span><br><span class="line">gcc -fPIC -shared b1.c a1.so -o b1.so</span><br><span class="line">gcc -fPIC -shared b2.c b2.so -o b2.so</span><br><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">b1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">b2</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">b1</span>();</span><br><span class="line">    <span class="built_in">b2</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/assets/SelfImp/ch7_19.png" alt="ch7_19.png"></li>
</ul>
</li>
</ul>
</li>
<li>重定位与初始化<ul>
<li>重定位完成后,如果某个共享对象有.init且可执行代码中没有该段,那么动态链接执行器会执行.init 段中的代码进行初始化， .finit 同理亦同</li>
</ul>
</li>
</ul>
<h3 id="7-6-显式运行时链接"><a href="#7-6-显式运行时链接" class="headerlink" title="7.6 显式运行时链接"></a>7.6 显式运行时链接</h3><ul>
<li>void* dlopen(const char* filename,int flag) ：打开一个动态库并加载到进程地址空间，完成初始化工程<ul>
<li>arg1 为相对路径时按照以下顺序查找动态库文件<ul>
<li>LD_LIBRARY_PATH指定的路径</li>
<li>&#x2F;etc&#x2F;ld.so.cache指定的共享路径</li>
<li>&#x2F;lib,&#x2F;usr</li>
</ul>
</li>
<li>arg2 RTLD_LAZY 表示延迟绑定，RTLD_NOW表示一次性加载， 二者必其一，RTLD_GLOBAL 表示将被加载的文件的符号加载到全局符号中</li>
<li>返回句柄， dlsym，dlclose使用,失败时返回NULL</li>
</ul>
</li>
<li>void *dlsym(void *handle, char *symbol):查找所需要的符号<ul>
<li>根据dlerror来判断成功与否</li>
<li>如果查找的符号是一个函数，则返回函数地址</li>
<li>如果查找的符号时个常量，则返回该常量的值</li>
</ul>
</li>
<li>char *dlerror():<ul>
<li>如果成功返回 NULL, 否者返回错误信息</li>
</ul>
</li>
<li>dlclose()<ul>
<li>对模块采取引用计数方式，为0时真正卸载掉</li>
</ul>
</li>
</ul>
<h2 id="8-Linux-共享库的组织"><a href="#8-Linux-共享库的组织" class="headerlink" title="8. Linux 共享库的组织"></a>8. Linux 共享库的组织</h2><ol>
<li>共享库版本命名</li>
</ol>
<ul>
<li>libname.so.x.y.z<ul>
<li>x 主版本号，表示库的重大升级，不同主版本号之间不兼容</li>
<li>y 此版本号，表示库的增量升级，向前兼容</li>
<li>z 发布版本号， 表示库的一些修正，性能的改进等，完全兼容</li>
</ul>
</li>
<li>SO-Name<ul>
<li>保留so的主版本号，即libname.so.x，通常使用软连接方式连接到具体版本</li>
<li>ldconfig 可以遍历所有默认共享库更新所有的软连接</li>
<li>-lXXX 会更更具系统中的相关路径查找最新的xxx库</li>
</ul>
</li>
<li>符号版本机制略</li>
</ul>
<ol start="2">
<li>共享库系统路径（FH 标准）</li>
</ol>
<ul>
<li>&#x2F;lib存放最关键和基础的库，主要是&#x2F;bin,&#x2F;sbin和系统启动需要的库</li>
<li>&#x2F;usr&#x2F;lib 存放非系统运行时所需要的关键性的库，主要是一些开发时用到的共享库</li>
<li>&#x2F;usr&#x2F;local&#x2F;lib 存放OS不相关的库，主要是第三方应用程序的库</li>
</ul>
<ol start="3">
<li>ldconfig 负责创建，删除或更新相应的SO-NAME, 并集中存放到&#x2F;etc&#x2F;ld.so.cache 里边，当动态链接器需要查找共享库时可以直接从ld.so.conf 查找</li>
<li>环境变量</li>
</ol>
<ul>
<li>LD_LIBRARY_PATH </li>
<li>LD_PRELOAD 预加载，尽量避免</li>
<li>LD_DEBUG</li>
</ul>
<ol start="5">
<li>strip 可以清除共享库或可执行文件的所有符号和调试信息</li>
</ol>
<h2 id="10-内存"><a href="#10-内存" class="headerlink" title="10. 内存"></a>10. 内存</h2><h3 id="10-1-程序的内存布局"><a href="#10-1-程序的内存布局" class="headerlink" title="10.1 程序的内存布局"></a>10.1 程序的内存布局</h3><p><img src="/assets/SelfImp/ch10_01.png" alt="ch10_01.png"></p>
<h3 id="10-2-堆与内存管理"><a href="#10-2-堆与内存管理" class="headerlink" title="10.2 堆与内存管理"></a>10.2 堆与内存管理</h3><ul>
<li>为了加快内存分配的速度，运行库适当的向OS 申请一块较大的内存，按需分配给程序使用，运行库使用brk()或mmap 申请内存</li>
<li>堆分配算法<ul>
<li>空闲链表法</li>
<li>位图</li>
<li>对象池</li>
<li>对于glibc 来说，小于64字节采用类似对象池的方法，大于512字节使用最佳适配法，大于64-512的使用上述方法折中，大于128KB 的使用mmap 直接向OS 申请</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://guangjin.fun">King Chan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://guangjin.fun/2022/10/26/SelfImproment/">http://guangjin.fun/2022/10/26/SelfImproment/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://guangjin.fun" target="_blank">Coder-King</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/c-%E6%8F%90%E9%AB%98/">c++提高</a><a class="post-meta__tags" href="/tags/%E9%93%BE%E6%8E%A5%E3%80%81%E8%A3%85%E8%BD%BD%E4%B8%8E%E5%BA%93/">链接、装载与库</a></div><div class="post_share"></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/reword.jpg" target="_blank"><img class="post-qr-code-img" src="/img/reword.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/11/05/StepIntro/"><img class="prev-cover" src="/img/mou.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">step文件初探</div></div></a></div><div class="next-post pull-right"><a href="/2022/10/22/CPPBase3/"><img class="next-cover" src="/img/mou.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">c++快速入门（3）--STL</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/dog.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">King Chan</div><div class="author-info__description">我要喝芝芝莓莓...</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">16</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:1761212789@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%B8%A9%E6%95%85%E8%80%8C%E7%9F%A5%E6%96%B0"><span class="toc-text">1. 温故而知新</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%BC%96%E8%AF%91%E4%B8%8E%E9%93%BE%E6%8E%A5"><span class="toc-text">2.编译与链接</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%EF%BC%88%E5%BC%80%E5%8F%91%E8%A7%86%E8%A7%92%EF%BC%89"><span class="toc-text">2.1 编译过程（开发视角）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%EF%BC%88%E7%BC%96%E8%AF%91%E5%99%A8%E8%A7%86%E8%A7%92%EF%BC%89"><span class="toc-text">2.2 编译过程（编译器视角）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6"><span class="toc-text">3.目标文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F"><span class="toc-text">3.1 目标文件格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E5%9F%BA%E6%9C%AC%E5%86%85%E5%AE%B9"><span class="toc-text">3.2 目标文件基本内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E4%B8%80%E4%B8%AA%E6%9C%89%E4%BB%A3%E8%A1%A8%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-text">3.3 一个有代表的例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E5%85%B6%E4%BB%96%E5%B8%B8%E8%A7%81%E7%9A%84%E6%AE%B5"><span class="toc-text">3.4 其他常见的段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-ELF-%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E6%8F%8F%E8%BF%B0"><span class="toc-text">3.5 ELF 文件结构描述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-1-ELF%E6%96%87%E4%BB%B6%E5%A4%B4"><span class="toc-text">3.5.1 ELF文件头</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-2-%E6%AE%B5%E8%A1%A8"><span class="toc-text">3.5.2 段表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-%E7%AC%A6%E5%8F%B7%E8%A1%A8-stmtab"><span class="toc-text">3.6 符号表(.stmtab)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-%E7%AC%A6%E5%8F%B7%E4%BF%AE%E9%A5%B0%E4%B8%8E%E5%87%BD%E6%95%B0%E7%AD%BE%E5%90%8D"><span class="toc-text">3.7 符号修饰与函数签名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-8-%E5%BC%BA%E5%BC%B1%E7%AC%A6%E5%8F%B7"><span class="toc-text">3.8 强弱符号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-9-%E5%BC%BA%E5%BC%B1%E5%BC%95%E7%94%A8"><span class="toc-text">3.9 强弱引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-text">4. 静态链接</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%90%88%E5%B9%B6-o%E6%96%87%E4%BB%B6"><span class="toc-text">4.1 合并.o文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-text">4.2 简单的例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-C-%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98"><span class="toc-text">4.3 C++ 相关问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E9%9D%99%E6%80%81%E5%BA%93%E9%93%BE%E6%8E%A5"><span class="toc-text">4.4 静态库链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-text">4.5 链接过程控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-BFD%E5%BA%93"><span class="toc-text">4.6 BFD库</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E8%A3%85%E8%BD%BD%E8%BF%9B%E7%A8%8B"><span class="toc-text">6. 可执行文件的装载进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-text">6.1 进程的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E8%BF%9B%E7%A8%8B%E5%AF%BB%E5%AD%98%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%86%E5%B8%83"><span class="toc-text">6.2 进程寻存空间的分布</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E5%A0%86%E6%A0%88"><span class="toc-text">6.3 堆栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-Linux-%E5%86%85%E6%A0%B8%E8%A3%85%E8%BD%BDELF-%E8%BF%87%E7%A8%8B%E7%AE%80%E4%BB%8B"><span class="toc-text">6.4 Linux 内核装载ELF 过程简介</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-text">7. 动态链接</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-text">7.1 一个简单的例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E5%9C%B0%E5%9D%80%E6%97%A0%E5%85%B3%E4%BB%A3%E7%A0%81"><span class="toc-text">7.2 地址无关代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9APLT"><span class="toc-text">7.3 延迟绑定PLT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E7%9A%84%E7%9B%B8%E5%85%B3%E7%BB%93%E6%9E%84"><span class="toc-text">7.4 动态链接的相关结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E7%9A%84%E6%AD%A5%E9%AA%A4%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="toc-text">7.5 动态链接的步骤和实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-%E6%98%BE%E5%BC%8F%E8%BF%90%E8%A1%8C%E6%97%B6%E9%93%BE%E6%8E%A5"><span class="toc-text">7.6 显式运行时链接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-Linux-%E5%85%B1%E4%BA%AB%E5%BA%93%E7%9A%84%E7%BB%84%E7%BB%87"><span class="toc-text">8. Linux 共享库的组织</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E5%86%85%E5%AD%98"><span class="toc-text">10. 内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-text">10.1 程序的内存布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-%E5%A0%86%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">10.2 堆与内存管理</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/19/CMM/" title="中药学">中药学</a><time datetime="2024-11-18T16:00:00.000Z" title="发表于 2024-11-19 00:00:00">2024-11-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/11/OTC/" title="中成药速通">中成药速通</a><time datetime="2024-11-10T16:00:00.000Z" title="发表于 2024-11-11 00:00:00">2024-11-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/03/TCMD1/" title="中医诊断学">中医诊断学</a><time datetime="2024-11-02T16:00:00.000Z" title="发表于 2024-11-03 00:00:00">2024-11-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/10/25/TCM3/" title="中医基础理论-3">中医基础理论-3</a><time datetime="2024-10-24T17:00:00.000Z" title="发表于 2024-10-25 01:00:00">2024-10-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/08/26/Spider/" title="python爬虫初探">python爬虫初探</a><time datetime="2024-08-25T16:00:00.000Z" title="发表于 2024-08-26 00:00:00">2024-08-26</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024 By King Chan</div><div class="footer_custom_text">welcome to coder-king</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script src="/js/weather.js"></script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>